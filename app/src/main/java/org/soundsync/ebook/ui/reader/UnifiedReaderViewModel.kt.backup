package org.soundsync.ebook.ui.reader

import android.Manifest
import android.app.Application
import android.accessibilityservice.AccessibilityServiceInfo
import android.content.ComponentName
import android.content.Context
import android.content.ContextWrapper
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.media.AudioAttributes
import android.media.MediaPlayer
import android.media.MediaRecorder
import android.os.Build
import android.os.Bundle
import android.os.IBinder
import android.os.Handler
import android.os.Looper
import android.speech.tts.TextToSpeech
import android.speech.tts.TextToSpeech.OnInitListener
import android.speech.tts.TextToSpeech.OnUtteranceProgressListener
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.edit
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import org.soundsync.ebook.MainActivity
import org.soundsync.ebook.R
import org.soundsync.ebook.data.local.dataStore
import org.soundsync.ebook.data.repository.BookRepository
import org.soundsync.ebook.data.repository.RecordRepository
import org.soundsync.ebook.data.repository.RecordRepositoryImpl
import org.soundsync.ebook.domain.model.Book
import org.soundsync.ebook.domain.model.Record
import org.soundsync.ebook.service.AudioCaptureService
import org.soundsync.ebook.ui.settings.SettingsViewModel
import org.soundsync.ebook.util.PageDirection
import org.soundsync.ebook.util.reader.BookReaderEngine
import org.soundsync.ebook.util.reader.SearchResult
import org.soundsync.ebook.util.reader.model.BookChapter
import org.soundsync.ebook.util.reader.model.ReaderConfig
import org.soundsync.ebook.util.reader.model.ReaderContent
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.io.File
import java.io.IOException
import java.util.Locale
import java.util.UUID
import kotlinx.coroutines.delay

/**
 * 统一的阅读器ViewModel
 * 支持所有格式的电子书，依赖于BookReaderEngine接口进行实际处理
 */
class UnifiedReaderViewModel(
    application: Application,
    private val bookRepository: BookRepository,
    private val recordRepository: RecordRepository,
    private val bookId: String
) : AndroidViewModel(application) {

    // 阅读引擎
    private var readerEngine: BookReaderEngine? = null
    
    // 录音文件播放相关
    private var mediaPlayer: MediaPlayer? = null
    private var currentPlayingRecord: Record? = null
    
    // UI状态
    private val _uiState = MutableStateFlow(UnifiedReaderUiState())
    val uiState: StateFlow<UnifiedReaderUiState> = _uiState.asStateFlow()
    
    // TTS引擎
    private var tts: TextToSpeech? = null
    private var isTtsActive = false
    
    // 录音相关
    private var mediaRecorder: MediaRecorder? = null
    private var isRecording = false
    private var recordStartTime = 0L
    private var recordFile: File? = null
    private var ttsRecordEnabled = false
    
    // 音频捕获服务
    private var audioCaptureService: AudioCaptureService? = null
    private var serviceBound = false
    
    // 服务连接
    private val serviceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            try {
                val binder = service as AudioCaptureService.LocalBinder
                audioCaptureService = binder.getService()
                serviceBound = true
                
                // 如果正在记录并且有媒体投影权限，尝试开始录音
                if (isRecording && MainActivity.getMediaProjection() != null) {
                    Log.d(TAG, "服务已连接，尝试开始内录")
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        startInternalRecording()
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "连接服务时发生错误: ${e.message}", e)
                serviceBound = false
                audioCaptureService = null
            }
        }
        
        override fun onServiceDisconnected(name: ComponentName?) {
            serviceBound = false
            audioCaptureService = null
            Log.d(TAG, "与音频捕获服务的连接已断开")
        }
    }
    
    // 常量
    companion object {
        private const val TAG = "UnifiedReaderViewModel"
        private const val RECORDING_PREFIX = "voc_"
    }
    
    init {
        loadBook()
        loadTtsRecordSettings()
        loadBookRecords()
    }
    
    /**
     * 加载TTS录音设置
     */
    private fun loadTtsRecordSettings() {
        viewModelScope.launch {
            try {
                getApplication<Application>().dataStore.data
                    .map { preferences -> 
                        preferences[SettingsViewModel.TTS_RECORD_KEY] ?: false 
                    }
                    .collect { enabled ->
                        ttsRecordEnabled = enabled
                        _uiState.update { it.copy(ttsRecordEnabled = enabled) }
                        Log.d(TAG, "TTS录音设置已加载: 已${if (enabled) "启用" else "禁用"}")
                    }
            } catch (e: Exception) {
                Log.e(TAG, "加载TTS录音设置失败: ${e.message}")
            }
        }
    }
    
    /**
     * 设置TTS录音功能开关
     */
    fun setTtsRecordEnabled(enabled: Boolean) {
        viewModelScope.launch {
            try {
                getApplication<Application>().dataStore.edit { preferences ->
                    preferences[SettingsViewModel.TTS_RECORD_KEY] = enabled
                }
                ttsRecordEnabled = enabled
                _uiState.update { it.copy(ttsRecordEnabled = enabled) }
                Log.d(TAG, "TTS录音设置已更新: 已${if (enabled) "启用" else "禁用"}")
            } catch (e: Exception) {
                Log.e(TAG, "更新TTS录音设置失败: ${e.message}")
            }
        }
    }
    
    /**
     * 加载书籍
     */
    private fun loadBook() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            try {
                // 从仓库获取书籍信息
                val book = bookRepository.getBookById(bookId)
                
                if (book != null) {
                    // 创建适合此书籍格式的阅读引擎
                    readerEngine = BookReaderEngine.create(getApplication(), book.type)
                    
                    // 初始化引擎
                    readerEngine?.initialize(book, book.lastReadPage)
                    
                    // 加载内容
                    readerEngine?.loadContent()
                    
                    // 初始化UI状态
                    readerEngine?.let { engine ->
                        _uiState.update { state ->
                            state.copy(
                                currentContent = engine.getCurrentPageContent(),
                                chapterTitle = engine.getCurrentChapterTitle()
                            )
                        }
                    }
                    
                    // 订阅引擎状态更新
                    observeEngineState()
                    
                    // 更新书籍的最后打开时间
                    bookRepository.updateLastOpenedDate(book.id, System.currentTimeMillis())
                } else {
                    _uiState.update { it.copy(error = "找不到图书") }
                }
            } catch (e: Exception) {
                _uiState.update { it.copy(error = "加载图书失败: ${e.message}") }
            } finally {
                _uiState.update { it.copy(isLoading = false) }
            }
        }
    }
    
    /**
     * 观察引擎状态
     */
    private fun observeEngineState() {
        readerEngine?.let { engine ->
            viewModelScope.launch {
                engine.state.collect { state ->
                    _uiState.update { uiState ->
                        uiState.copy(
                            book = state.book,
                            currentPage = state.currentPage,
                            totalPages = state.totalPages,
                            currentChapter = state.currentChapter,
                            totalChapters = state.totalChapters,
                            readingProgress = state.readingProgress,
                            currentContent = engine.getCurrentPageContent(),
                            chapterTitle = engine.getCurrentChapterTitle()
                        )
                    }
                }
            }
        }
    }
    
    /**
     * 初始化文本朗读
     */
    fun initTts(onInitListener: (status: Int) -> Unit) {
        if (tts == null) {
            tts = TextToSpeech(getApplication()) { status ->
                if (status == TextToSpeech.SUCCESS) {
                    tts?.language = Locale.CHINESE
                    
                    // 设置TTS进度监听器
                    tts?.setOnUtteranceProgressListener(object : OnUtteranceProgressListener() {
                        override fun onStart(utteranceId: String?) {
                            Log.d(TAG, "开始朗读: $utteranceId")
                            
                            // 如果TTS录音功能已启用，开始录音
                            if (ttsRecordEnabled && !isRecording) {
                                startRecording()
                            }
                        }
                        
                        override fun onDone(utteranceId: String?) {
                            Log.d(TAG, "朗读完成: $utteranceId")
                            
                            // TTS朗读完成后，如果正在录音，停止录音并保存
                            if (isRecording) {
                                stopRecordingAndSave()
                            }
                            
                            // 如果还在朗读模式，自动朗读下一页
                            if (isTtsActive) {
                                viewModelScope.launch {
                                    if (readerEngine?.hasNextPage() == true) {
                                        navigatePage(PageDirection.NEXT)
                                    } else {
                                        // 已到最后一页，停止朗读
                                        isTtsActive = false
                                    }
                                }
                            }
                        }
                        
                        override fun onError(utteranceId: String?) {
                            Log.e(TAG, "朗读错误: $utteranceId")
                            
                            // 如果发生错误，停止录音
                            if (isRecording) {
                                stopRecordingAndSave()
                            }
                            
                            isTtsActive = false
                        }
                    })
                    
                    readerEngine?.initTts(tts!!)
                }
                onInitListener(status)
            }
        } else {
            onInitListener(TextToSpeech.SUCCESS)
        }
    }
    
    /**
     * 开始或停止朗读
     */
    fun toggleTts(): Boolean {
        isTtsActive = !isTtsActive
        
        if (isTtsActive) {
            speakCurrentPage()
        } else {
            tts?.stop()
            
            // 停止TTS时，如果正在录音，停止录音并保存
            if (isRecording) {
                stopRecordingAndSave()
            }
        }
        
        return isTtsActive
    }
    
    /**
     * 朗读当前页面
     */
    private fun speakCurrentPage() {
        val textToSpeak = readerEngine?.getCurrentPageText() ?: return
        
        if (textToSpeak.isNotEmpty() && isTtsActive) {
            val params = Bundle()
            val utteranceId = "TTS_${UUID.randomUUID()}"
            tts?.speak(
                textToSpeak,
                TextToSpeech.QUEUE_FLUSH,
                params,
                utteranceId
            )
            
            // 如果启用了TTS录音，并且当前没有在录音，则开始录音
            if (ttsRecordEnabled && !isRecording) {
                startRecording()
            }
        }
    }
    
    /**
     * 开始录音
     */
    private fun startRecording() {
        try {
            // 检查Android版本
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
                Log.d(TAG, "Android版本低于10，不支持内录功能")
                _uiState.update { it.copy(error = "内录功能需要Android 10或更高版本") }
                return
            }
            
            viewModelScope.launch {
                // 获取MainActivity实例和Context
                val context = getApplication<Application>().applicationContext
                val mainActivity = context.findMainActivity()
                
                // 创建录音目录
                val recordDir = try {
                    (recordRepository as? RecordRepositoryImpl)?.createRecordDirectory()
                } catch (e: Exception) {
                    null
                } ?: File(context.filesDir, "book_records").apply { 
                    if (!exists()) mkdirs() 
                }
                
                // 创建录音文件（使用时间戳作为唯一标识）
                val timestamp = System.currentTimeMillis()
                recordFile = File(recordDir, "${RECORDING_PREFIX}${timestamp}.mp3")
                
                // 标记开始录音
                isRecording = true
                recordStartTime = System.currentTimeMillis()
                
                // 判断服务和媒体投影是否准备就绪
                if (serviceBound && audioCaptureService != null && MainActivity.getMediaProjection() != null) {
                    // 服务和媒体投影都已经就绪，直接开始内录
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        Log.d(TAG, "服务和媒体投影已就绪，直接开始内录")
                        startInternalRecording()
                        return@launch  // 已启动录音，无需后续处理
                    }
                }
                
                // 如果未能直接启动内录（服务或媒体投影未就绪），执行以下步骤
                // 连接音频捕获服务
                bindAudioCaptureService()
                
                // 请求媒体投影权限（用于内录）
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                    if (mainActivity != null) {
                        mainActivity.requestMediaProjectionPermission()
                        Log.d(TAG, "录音请求已发送")
                    } else {
                        // 无法获取MainActivity，使用降级策略
                        Log.e(TAG, "无法获取MainActivity实例，使用降级录音方式")
                        
                        if (hasRecordPermission()) {
                            // 降级为标准麦克风录音
                            fallbackToStandardRecording()
                        } else {
                            _uiState.update { it.copy(error = "无法获取主Activity且缺少录音权限") }
                            isRecording = false
                            recordFile = null
                        }
                    }
                } else {
                    _uiState.update { it.copy(error = "您的设备不支持内录功能") }
                    isRecording = false
                    recordFile = null
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "开始录音失败: ${e.message}", e)
            releaseMediaRecorder()
            isRecording = false
            recordFile = null
            _uiState.update { it.copy(error = "录音功能不可用: ${e.message}") }
        }
    }
    
    /**
     * 降级使用标准MediaRecorder录音
     */
    private fun fallbackToStandardRecording() {
        try {
            Log.d(TAG, "使用标准麦克风录音作为降级方案")
            
            // 释放可能存在的资源
            releaseMediaRecorder()
            
            // 确保我们有录音权限
            if (!hasRecordPermission()) {
                Log.e(TAG, "标准录音失败：没有录音权限")
                _uiState.update { it.copy(error = "请授予录音权限") }
                isRecording = false
                recordFile = null
                return
            }
            
            // 确保recordFile存在
            if (recordFile == null || !recordFile!!.parentFile!!.exists()) {
                val context = getApplication<Application>().applicationContext
                val recordDir = File(context.filesDir, "book_records").apply { 
                    if (!exists()) mkdirs() 
                }
                
                // 创建新的录音文件
                val timestamp = System.currentTimeMillis()
                recordFile = File(recordDir, "${RECORDING_PREFIX}${timestamp}.mp3")
                recordStartTime = System.currentTimeMillis()
                Log.d(TAG, "创建新的录音文件: ${recordFile?.absolutePath}")
            }
            
            val filePath = recordFile?.absolutePath
            if (filePath == null) {
                Log.e(TAG, "标准录音失败：文件路径为空")
                _uiState.update { it.copy(error = "无法创建录音文件") }
                isRecording = false
                return
            }
            
            // 尝试多种音频源
            val audioSources = listOf(
                MediaRecorder.AudioSource.MIC,               // 常规麦克风
                MediaRecorder.AudioSource.VOICE_RECOGNITION, // 语音识别优化
                MediaRecorder.AudioSource.CAMCORDER,         // 摄像机音频
                MediaRecorder.AudioSource.VOICE_COMMUNICATION // 通话音频
            )
            
            var recordingStarted = false
            
            for (audioSource in audioSources) {
                // 初始化 MediaRecorder
                mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    MediaRecorder(getApplication())
                } else {
                    @Suppress("DEPRECATION")
                    MediaRecorder()
                }
                
                try {
                    mediaRecorder?.apply {
                        // 设置音频源和输出格式
                        setAudioSource(audioSource)
                        setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)
                        setOutputFile(filePath)
                        setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
                        setAudioSamplingRate(44100)
                        setAudioEncodingBitRate(96000)
                        
                        // 准备并开始录音
                        prepare()
                        start()
                        Log.d(TAG, "标准录音已开始（音源:$audioSource）: $filePath")
                        recordingStarted = true
                        return@apply
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "音源 $audioSource 录音失败: ${e.message}")
                    mediaRecorder?.reset()
                    mediaRecorder?.release()
                    mediaRecorder = null
                    // 继续尝试下一个音源
                }
            }
            
            if (!recordingStarted) {
                Log.e(TAG, "所有标准录音方式均失败")
                releaseMediaRecorder()
                recordFile?.delete()
                _uiState.update { it.copy(error = "无法启动录音，请检查设备麦克风权限") }
                isRecording = false
                recordFile = null
            }
        } catch (e: Exception) {
            Log.e(TAG, "初始化标准录音失败: ${e.message}", e)
            releaseMediaRecorder()
            recordFile?.delete()
            _uiState.update { it.copy(error = "录音初始化失败: ${e.message}") }
            isRecording = false
            recordFile = null
        }
    }
    
    /**
     * 尝试查找MainActivity实例
     */
    private fun Context.findMainActivity(): MainActivity? {
        Log.d(TAG, "尝试查找MainActivity实例")
        
        try {
            // 1. 首先尝试使用全局单例获取MainActivity
            val mainActivityFromSingleton = MainActivity.getInstance()
            if (mainActivityFromSingleton != null) {
                Log.d(TAG, "从全局单例成功获取MainActivity实例")
                return mainActivityFromSingleton
            }
            
            // 2. 尝试通过上下文链查找
            var currentContext: Context? = this
            while (currentContext != null) {
                // 如果当前上下文就是MainActivity
                if (currentContext is MainActivity) {
                    Log.d(TAG, "在上下文链中找到MainActivity实例")
                    return currentContext
                }
                
                // 向上查找
                if (currentContext is ContextWrapper) {
                    currentContext = currentContext.baseContext
                } else {
                    // 如果不是ContextWrapper，无法再向上查找
                    break
                }
            }
    
            // 3. 所有尝试都失败，记录日志
            Log.e(TAG, "无法找到MainActivity实例，将使用降级录音方式")
            return null
        } catch (e: Exception) {
            Log.e(TAG, "查找MainActivity过程中发生异常: ${e.message}", e)
            return null
        }
    }
    
    /**
     * 检查是否有录音权限
     */
    private fun hasRecordPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            getApplication(),
            Manifest.permission.RECORD_AUDIO
        ) == PackageManager.PERMISSION_GRANTED
    }
    
    /**
     * 停止录音并保存到数据库
     */
    private fun stopRecordingAndSave() {
        if (!isRecording || recordFile == null) return
        
        try {
            // 保存录音文件路径以供后续使用
            val finalRecordFilePath = recordFile?.absolutePath
            var savedRecordPath: String? = null
            
            // 检查是否为华为设备
            val isHuaweiDevice = isHuaweiDevice()
            
            // 1. 尝试通过无障碍服务停止录音（华为设备优先尝试）
            if (isHuaweiDevice) {
                val accessibilityService = org.soundsync.ebook.service.AudioCaptureAccessibilityService.getInstance()
                if (accessibilityService != null) {
                    savedRecordPath = accessibilityService.stopRecording()
                    if (savedRecordPath != null) {
                        Log.d(TAG, "通过无障碍服务停止录音成功: $savedRecordPath")
                    }
                }
            }
            
            // 2. 尝试标准内录服务停止录音
            if (savedRecordPath == null && audioCaptureService != null && serviceBound && !isHuaweiDevice) {
                // 停止内录服务的录音
                savedRecordPath = audioCaptureService?.stopRecording()
                
                if (savedRecordPath == null) {
                    Log.e(TAG, "内录保存失败：未获取到录音文件路径")
                    // 不直接更新UI错误，我们将尝试使用标准方式保存的录音
                }
            } 
            
            // 3. 尝试标准麦克风录音停止
            if (savedRecordPath == null && mediaRecorder != null) {
                // 如果使用的是降级为标准MediaRecorder
                try {
                    mediaRecorder?.apply {
                        stop()
                        reset()
                        release()
                    }
                    mediaRecorder = null
                    savedRecordPath = finalRecordFilePath
                    Log.d(TAG, "标准录音已停止: $savedRecordPath")
                } catch (e: Exception) {
                    Log.e(TAG, "停止降级录音失败: ${e.message}", e)
                    // 即使停止失败，也要尝试使用文件路径，因为录音可能已经部分保存
                    savedRecordPath = finalRecordFilePath
                    // 尝试释放资源
                    try {
                        mediaRecorder?.reset()
                        mediaRecorder?.release()
                    } catch (e2: Exception) {
                        Log.e(TAG, "释放MediaRecorder资源时出错: ${e2.message}")
                    } finally {
                        mediaRecorder = null
                    }
                }
            } else if (savedRecordPath == null) {
                Log.e(TAG, "录音未正确初始化或所有停止方法均失败")
                recordFile?.delete()
                isRecording = false
                releaseMediaRecorder()
                return
            }
            
            isRecording = false
            
            // 使用成功的录音路径，如果内录失败则使用预设路径
            val actualRecordPath = savedRecordPath ?: finalRecordFilePath ?: ""
            
            // 如果没有有效的路径，则退出
            if (actualRecordPath.isEmpty()) {
                Log.e(TAG, "无法获取有效的录音文件路径")
                _uiState.update { it.copy(error = "录音失败：无法获取录音文件路径") }
                releaseMediaRecorder()
                return
            }
            
            // 检查文件是否存在
            val recordFile = File(actualRecordPath)
            if (!recordFile.exists()) {
                Log.e(TAG, "录音文件不存在: $actualRecordPath")
                _uiState.update { it.copy(error = "录音文件未能正确保存") }
                releaseMediaRecorder()
                return
            }
            
            // 检查文件大小是否足够（至少1KB）
            if (recordFile.length() < 1024) {
                Log.e(TAG, "录音文件过小(${recordFile.length()}字节)，可能录音失败")
                recordFile.delete()
                _uiState.update { it.copy(error = "录音质量不佳，已删除") }
                releaseMediaRecorder()
                return
            }
            
            // 计算录音时长（秒）
            val recordDuration = ((System.currentTimeMillis() - recordStartTime) / 1000).toInt()
            
            if (recordDuration <= 1) {
                // 录音时间太短，删除文件
                Log.d(TAG, "录音时间太短，删除录音文件")
                recordFile.delete()
                releaseMediaRecorder()
                return
            }
            
            // 保存录音信息到数据库
            viewModelScope.launch {
                val record = Record(
                    bookId = bookId,
                    voiceFilePath = actualRecordPath,
                    voiceLength = recordDuration,
                    addedDate = System.currentTimeMillis()
                )
                
                try {
                    val recordId = recordRepository.addRecord(record)
                    Log.d(TAG, "录音已停止并保存: $actualRecordPath, 时长: ${recordDuration}秒, ID: $recordId")
                    
                    // 立即刷新录音列表
                    refreshRecordsList()
                    
                    // 显示成功提示
                    _uiState.update { it.copy(error = null) }
                } catch (e: Exception) {
                    Log.e(TAG, "保存录音数据失败: ${e.message}")
                    _uiState.update { it.copy(error = "保存录音信息到数据库失败: ${e.message}") }
                    // 文件已保存，但数据库记录失败，考虑是否删除文件
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "停止录音失败: ${e.message}")
            _uiState.update { it.copy(error = "停止录音出错: ${e.message}") }
        } finally {
            releaseMediaRecorder()
        }
    }
    
    /**
     * 刷新录音列表
     */
    private fun refreshRecordsList() {
        viewModelScope.launch {
            try {
                recordRepository.getRecordsByBookId(bookId).collect { records ->
                    _uiState.update { it.copy(records = records) }
                    Log.d(TAG, "录音列表已刷新，共 ${records.size} 个录音")
                }
            } catch (e: Exception) {
                Log.e(TAG, "刷新录音列表失败: ${e.message}")
            }
        }
    }
    
    /**
     * 释放MediaRecorder资源
     */
    private fun releaseMediaRecorder() {
        try {
            mediaRecorder?.reset()
            mediaRecorder?.release()
            mediaRecorder = null
            isRecording = false
            
            // 断开录音服务
            unbindAudioCaptureService()
        } catch (e: Exception) {
            Log.e(TAG, "释放MediaRecorder失败: ${e.message}")
        }
    }
    
    /**
     * 翻页
     */
    fun navigatePage(direction: PageDirection) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止当前页的朗读
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.navigatePage(direction)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 跳转到指定页面
     */
    fun goToPage(page: Int) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.goToPage(page)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 跳转到指定章节
     */
    fun goToChapter(chapterIndex: Int) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.goToChapter(chapterIndex)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 获取当前页面内容
     */
    fun getContentForCurrentPage(): String {
        return readerEngine?.getCurrentPageText() ?: ""
    }
    
    /**
     * 获取章节列表
     */
    fun getChapters(): List<BookChapter> {
        return readerEngine?.getChapters() ?: emptyList()
    }
    
    /**
     * 更新阅读器配置
     */
    fun updateConfig(config: ReaderConfig) {
        viewModelScope.launch {
            readerEngine?.updateConfig(config)
        }
    }
    
    /**
     * 保存阅读进度
     */
    private suspend fun saveReadingProgress() {
        val book = uiState.value.book ?: return
        val currentPage = uiState.value.currentPage
        
        try {
            bookRepository.updateReadingProgress(
                bookId = book.id,
                lastReadPage = currentPage,
                lastReadPosition = uiState.value.readingProgress
            )
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "保存进度失败: ${e.message}") }
        }
    }
    
    /**
     * 搜索文本
     */
    fun searchText(query: String) {
        viewModelScope.launch {
            try {
                _uiState.update { it.copy(isSearching = true) }
                
                val results = readerEngine?.searchText(query) ?: emptyList()
                
                _uiState.update { state ->
                    state.copy(
                        searchResults = results,
                        isSearching = false
                    )
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        error = "搜索失败: ${e.message}",
                        isSearching = false
                    ) 
                }
            }
        }
    }
    
    /**
     * 获取书籍封面
     */
    fun getBookCover(): Bitmap? {
        return uiState.value.book?.coverPath?.let {
            try {
                android.graphics.BitmapFactory.decodeFile(it)
            } catch (e: Exception) {
                null
            }
        }
    }
    
    /**
     * 加载当前书籍的录音文件
     */
    private fun loadBookRecords() {
        viewModelScope.launch {
            try {
                recordRepository.getRecordsByBookId(bookId).collect { records ->
                    _uiState.update { it.copy(records = records) }
                    Log.d(TAG, "已加载 ${records.size} 个录音文件")
                }
            } catch (e: Exception) {
                Log.e(TAG, "加载录音文件失败: ${e.message}")
            }
        }
    }
    
    /**
     * 播放录音文件
     */
    fun playRecord(record: Record) {
        try {
            // 如果有正在播放的录音，先停止
            stopPlayingRecord()
            
            val recordFile = File(record.voiceFilePath)
            if (!recordFile.exists()) {
                Log.e(TAG, "录音文件不存在: ${record.voiceFilePath}")
                return
            }
            
            mediaPlayer = MediaPlayer().apply {
                setAudioAttributes(
                    AudioAttributes.Builder()
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .build()
                )
                setDataSource(record.voiceFilePath)
                setOnPreparedListener { mp ->
                    mp.start()
                    currentPlayingRecord = record
                    _uiState.update { it.copy(currentPlayingRecordId = record.recId) }
                }
                setOnCompletionListener {
                    stopPlayingRecord()
                }
                prepareAsync()
            }
        } catch (e: Exception) {
            Log.e(TAG, "播放录音文件失败: ${e.message}")
            stopPlayingRecord()
        }
    }
    
    /**
     * 暂停播放录音
     */
    fun pauseRecord(record: Record) {
        try {
            if (currentPlayingRecord?.recId == record.recId && mediaPlayer?.isPlaying == true) {
                mediaPlayer?.pause()
                _uiState.update { it.copy(currentPlayingRecordId = null) }
                currentPlayingRecord = null
            }
        } catch (e: Exception) {
            Log.e(TAG, "暂停录音文件失败: ${e.message}")
        }
    }
    
    /**
     * 停止播放录音文件
     */
    private fun stopPlayingRecord() {
        try {
            mediaPlayer?.apply {
                if (isPlaying) {
                    stop()
                }
                reset()
                release()
            }
            mediaPlayer = null
            currentPlayingRecord = null
            _uiState.update { it.copy(currentPlayingRecordId = null) }
        } catch (e: Exception) {
            Log.e(TAG, "停止播放录音文件失败: ${e.message}")
        }
    }
    
    /**
     * 清理资源
     */
    override fun onCleared() {
        super.onCleared()
        
        viewModelScope.launch {
            saveReadingProgress()
            
            // 停止TTS
            tts?.stop()
            tts?.shutdown()
            tts = null
            
            // 停止录音
            if (isRecording) {
                stopRecordingAndSave()
            }
            
            // 尝试停止无障碍服务录音
            try {
                val accessibilityService = org.soundsync.ebook.service.AudioCaptureAccessibilityService.getInstance()
                accessibilityService?.stopRecording()
            } catch (e: Exception) {
                Log.e(TAG, "停止无障碍服务录音失败: ${e.message}")
            }
            
            // 释放播放器资源
            stopPlayingRecord()
            
            readerEngine?.close()
            readerEngine = null
        }
        
        // 清理服务连接
        try {
            if (serviceBound) {
                getApplication<Application>().applicationContext.unbindService(serviceConnection)
                serviceBound = false
                audioCaptureService = null
            }
        } catch (e: Exception) {
            Log.e(TAG, "解绑服务失败: ${e.message}")
        }
    }

    private fun formatProgressText(): String {
        val currentPage = uiState.value.currentPage + 1
        val totalPages = uiState.value.totalPages
        return "${currentPage}/${totalPages}"
    }

    /**
     * 开始内部录音（内录）
     */
    @RequiresApi(Build.VERSION_CODES.Q)
    private fun startInternalRecording() {
        try {
            Log.d(TAG, "开始内部录音（内录）")
            
            // 检查是否为华为设备并处理特殊情况
            val isHuaweiDevice = isHuaweiDevice()
            val manufacturer = Build.MANUFACTURER
            Log.d(TAG, "设备制造商: $manufacturer")
            
            if (isHuaweiDevice) {
                // 尝试使用华为专用内录方法
                val huaweiInternalRecordingResult = tryHuaweiInternalRecording()
                if (huaweiInternalRecordingResult) {
                    Log.d(TAG, "使用华为专用方法开始内录成功")
                    return
                }
                
                // 华为专用方法失败，回退到麦克风录音
                Log.d(TAG, "华为专用方法失败，使用标准麦克风录音作为替代方案")
                if (hasRecordPermission()) {
                    fallbackToStandardRecording()
                    return
                } else {
                    Log.e(TAG, "华为设备无法获取录音权限")
                    _uiState.update { it.copy(error = "无法获取录音权限") }
                    isRecording = false
                    recordFile = null
                    return
                }
            }
            
            // 以下是非华为设备的内录处理逻辑
            if (!serviceBound || audioCaptureService == null) {
                Log.e(TAG, "无法开始内录：服务未连接，尝试使用标准录音")
                
                // 服务未连接时，尝试使用标准录音作为备选方案
                if (hasRecordPermission()) {
                    fallbackToStandardRecording()
                    return
                } else {
                    _uiState.update { it.copy(error = "内录服务未连接且无录音权限") }
                    isRecording = false
                    recordFile = null
                    return
                }
            }
            
            // 检查媒体投影是否存在
            val mediaProjection = MainActivity.getMediaProjection()
            if (mediaProjection == null) {
                Log.e(TAG, "无法开始内录：媒体投影为空，尝试使用标准录音")
                
                // 媒体投影为空时，尝试使用标准录音作为备选方案
                if (hasRecordPermission()) {
                    fallbackToStandardRecording()
                    return
                } else {
                    _uiState.update { it.copy(error = "媒体投影权限未获取且无录音权限") }
                    isRecording = false
                    recordFile = null
                    return
                }
            }
            
            // 确保已设置媒体投影
            audioCaptureService?.setMediaProjection(mediaProjection)
            
            // 确保记录文件路径存在
            val filePath = recordFile?.absolutePath
            if (filePath == null) {
                Log.e(TAG, "无法开始内录：录音文件路径为空")
                _uiState.update { it.copy(error = "录音文件路径无效") }
                isRecording = false
                return
            }
            
            // 开始录音
            val success = audioCaptureService?.startRecording(filePath) ?: false
            
            if (success) {
                Log.d(TAG, "内录已成功开始: $filePath")
            } else {
                Log.e(TAG, "开始内录失败，尝试使用标准录音")
                
                // 内录失败时，尝试使用标准录音作为备选方案
                if (hasRecordPermission()) {
                    fallbackToStandardRecording()
                } else {
                    _uiState.update { it.copy(error = "内录失败且无录音权限") }
                    isRecording = false
                    recordFile = null
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "开始内录时发生异常: ${e.message}", e)
            
            // 发生异常时，尝试使用标准录音作为备选方案
            if (hasRecordPermission()) {
                Log.d(TAG, "内录异常，尝试使用标准录音")
                try {
                    fallbackToStandardRecording()
                } catch (e2: Exception) {
                    Log.e(TAG, "降级到标准录音也失败: ${e2.message}", e2)
                    _uiState.update { it.copy(error = "录音启动失败: ${e2.message}") }
                    isRecording = false
                    recordFile = null
                }
            } else {
                _uiState.update { it.copy(error = "内录启动错误: ${e.message}") }
                isRecording = false
                recordFile = null
            }
        }
    }
    
    /**
     * 检查是否为华为设备
     */
    private fun isHuaweiDevice(): Boolean {
        val manufacturer = Build.MANUFACTURER ?: ""
        val brand = Build.BRAND ?: ""
        val model = Build.MODEL ?: ""
        
        // 记录设备信息以便调试
        Log.d(TAG, "设备信息 - 制造商: $manufacturer, 品牌: $brand, 型号: $model")
        
        // 检查制造商、品牌或型号是否包含HUAWEI字样
        val isHuawei = manufacturer.contains("HUAWEI", ignoreCase = true) || 
                       brand.contains("HUAWEI", ignoreCase = true) ||
                       manufacturer.contains("华为", ignoreCase = true) ||
                       model.startsWith("HUAWEI", ignoreCase = true) ||
                       model.startsWith("华为", ignoreCase = true)
        
        if (isHuawei) {
            Log.d(TAG, "检测到华为设备: $manufacturer $brand $model")
        }
        
        return isHuawei
    }

    /**
     * 绑定音频捕获服务
     */
    private fun bindAudioCaptureService() {
        try {
            if (!serviceBound) {
                val context = getApplication<Application>()
                val intent = Intent(context, AudioCaptureService::class.java)
                
                // 先启动服务
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    context.startForegroundService(intent)
                } else {
                    context.startService(intent)
                }
                
                // 然后绑定服务
                context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)
                Log.d(TAG, "音频捕获服务绑定请求已发送")
            }
        } catch (e: Exception) {
            Log.e(TAG, "绑定音频捕获服务失败: ${e.message}", e)
        }
    }
    
    /**
     * 解绑音频捕获服务
     */
    private fun unbindAudioCaptureService() {
        try {
            if (serviceBound) {
                getApplication<Application>().unbindService(serviceConnection)
                serviceBound = false
                audioCaptureService = null
                Log.d(TAG, "音频捕获服务已解绑")
            }
        } catch (e: Exception) {
            Log.e(TAG, "解绑音频捕获服务失败: ${e.message}", e)
        }
    }

    /**
     * 尝试使用华为专用方法实现内录功能
     * 返回是否成功开始内录
     */
    private fun tryHuaweiInternalRecording(): Boolean {
        try {
            Log.d(TAG, "尝试使用华为专用方法实现内录")
            
            // 确保我们有录音权限
            if (!hasRecordPermission()) {
                Log.e(TAG, "华为内录功能需要录音权限")
                return false
            }
            
            // 检查华为设备版本和支持情况
            val isHuaweiP30Pro = checkIsHuaweiP30Pro()
            val emuiVersion = getEMUIVersion()
            Log.d(TAG, "华为设备型号匹配P30 Pro: $isHuaweiP30Pro, EMUI版本: $emuiVersion")
            
            // 获取文件路径
            val filePath = recordFile?.absolutePath ?: run {
                Log.e(TAG, "华为内录失败：文件路径为空")
                return false
            }
            
            // 方法1：尝试使用AudioManager的特殊参数
            val result = tryHuaweiAudioManagerMethod(filePath)
            if (result) {
                return true
            }
            
            // 方法2：尝试使用AccessibilityService方式
            // 该方法需要用户先授予无障碍权限，此处仅作检测
            if (isAccessibilityServiceEnabled()) {
                val accessibilityResult = tryAccessibilityInternalRecording(filePath)
                if (accessibilityResult) {
                    return true
                }
            }
            
            // 方法3：使用VirtualDisplay方式 (适用于某些华为机型)
            if (MainActivity.getMediaProjection() != null) {
                val virtualDisplayResult = tryVirtualDisplayRecording(filePath)
                if (virtualDisplayResult) {
                    return true
                }
            }
            
            // 所有方法都失败，返回false
            Log.e(TAG, "所有华为专用内录方法均失败")
            return false
        } catch (e: Exception) {
            Log.e(TAG, "华为专用内录方法异常: ${e.message}", e)
            return false
        }
    }
    
    /**
     * 尝试使用华为AudioManager特殊参数实现内录
     */
    private fun tryHuaweiAudioManagerMethod(filePath: String): Boolean {
        try {
            Log.d(TAG, "尝试使用华为AudioManager特殊参数实现内录")
            
            // 初始化 MediaRecorder
            mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                MediaRecorder(getApplication())
            } else {
                @Suppress("DEPRECATION")
                MediaRecorder()
            }
            
            // 先尝试REMOTE_SUBMIX音源
            if (tryWithAudioSource(MediaRecorder.AudioSource.REMOTE_SUBMIX, filePath)) {
                return true
            }
            
            // 如果REMOTE_SUBMIX失败，尝试VOICE_COMMUNICATION音源
            if (tryWithAudioSource(MediaRecorder.AudioSource.VOICE_COMMUNICATION, filePath)) {
                return true
            }
            
            // 如果VOICE_COMMUNICATION失败，再尝试VOICE_RECOGNITION音源
            if (tryWithAudioSource(MediaRecorder.AudioSource.VOICE_RECOGNITION, filePath)) {
                return true
            }
            
            // 所有尝试均失败
            return false
        } catch (e: Exception) {
            Log.e(TAG, "华为AudioManager方法异常: ${e.message}", e)
            releaseMediaRecorder()
            return false
        }
    }
    
    /**
     * 使用指定音源尝试录音
     */
    private fun tryWithAudioSource(audioSource: Int, filePath: String): Boolean {
        try {
            // 重新初始化 MediaRecorder 如果已经被使用
            if (mediaRecorder == null) {
                mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    MediaRecorder(getApplication())
                } else {
                    @Suppress("DEPRECATION")
                    MediaRecorder()
                }
            }
            
            mediaRecorder?.apply {
                try {
                    // 设置指定音频源
                    setAudioSource(audioSource)
                    setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)
                    setOutputFile(filePath)
                    setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
                    setAudioSamplingRate(44100)
                    setAudioEncodingBitRate(128000)
                    
                    // 准备并开始录音
                    prepare()
                    start()
                    Log.d(TAG, "使用音源 $audioSource 录音已开始: $filePath")
                    return true
                } catch (e: Exception) {
                    Log.e(TAG, "使用音源 $audioSource 录音失败: ${e.message}")
                    // 不调用releaseMediaRecorder，因为我们可能还要尝试其他音源
                    mediaRecorder?.reset()
                    return false
                }
            }
            
            return false
        } catch (e: Exception) {
            Log.e(TAG, "尝试音源 $audioSource 时发生异常: ${e.message}")
            mediaRecorder?.reset()
            return false
        }
    }
    
    /**
     * 尝试使用AccessibilityService方式实现内录
     */
    private fun tryAccessibilityInternalRecording(filePath: String): Boolean {
        try {
            Log.d(TAG, "尝试通过无障碍服务实现内录")
            
            // 获取无障碍服务实例
            val accessibilityService = org.soundsync.ebook.service.AudioCaptureAccessibilityService.getInstance()
            
            if (accessibilityService == null) {
                Log.e(TAG, "无障碍服务实例为空，请确保已启用无障碍服务")
                
                // 引导用户开启无障碍服务
                showAccessibilityServiceGuide()
                return false
            }
            
            // 使用无障碍服务实现内录
            val result = accessibilityService.startRecording(filePath)
            
            if (result) {
                Log.d(TAG, "通过无障碍服务成功开始内录")
                return true
            } else {
                Log.e(TAG, "通过无障碍服务开始内录失败")
                return false
            }
        } catch (e: Exception) {
            Log.e(TAG, "通过无障碍服务实现内录时发生异常: ${e.message}", e)
            return false
        }
    }
    
    /**
     * 显示无障碍服务开启引导
     */
    private fun showAccessibilityServiceGuide() {
        // 更新UI状态，显示无障碍服务引导提示
        _uiState.update { 
            it.copy(
                showAccessibilityGuide = true
            ) 
        }
        
        // 获取Application上下文
        val context = getApplication<Application>().applicationContext
        
        try {
            // 创建意图，打开无障碍服务设置页面
            val intent = Intent(android.provider.Settings.ACTION_ACCESSIBILITY_SETTINGS).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            }
            
            // 创建消息提示
            val message = context.getString(R.string.huawei_accessibility_guide_message)
            
            // 在主线程中显示对话框（需要使用Activity Context）
            val mainActivity = findMainActivity()
            if (mainActivity != null) {
                Handler(Looper.getMainLooper()).post {
                    AlertDialog.Builder(mainActivity)
                        .setTitle(context.getString(R.string.huawei_accessibility_guide_title))
                        .setMessage(message)
                        .setPositiveButton(context.getString(R.string.go_to_settings)) { dialog, _ -> 
                            dialog.dismiss()
                            context.startActivity(intent)
                        }
                        .setNegativeButton(android.R.string.cancel, null)
                        .setCancelable(false)
                        .show()
                }
            } else {
                // 未获取到Activity，直接打开设置
                context.startActivity(intent)
            }
        } catch (e: Exception) {
            Log.e(TAG, "无法打开无障碍服务设置页面: ${e.message}", e)
            _uiState.update { 
                it.copy(
                    error = "请手动前往设置 > 无障碍 > 已安装的服务，开启"随声阅内录服务""
                ) 
            }
        }
    }
    
    /**
     * 检查是否是华为P30 Pro
     */
    private fun checkIsHuaweiP30Pro(): Boolean {
        val model = Build.MODEL ?: ""
        return model.contains("P30 Pro", ignoreCase = true) ||
               model.contains("VOG-L29", ignoreCase = true) ||  // 国际版
               model.contains("VOG-L09", ignoreCase = true) ||  // 欧洲版
               model.contains("VOG-AL00", ignoreCase = true) || // 中国版
               model.contains("VOG-TL00", ignoreCase = true)    // 中国电信版
    }
    
    /**
     * 获取华为EMUI版本
     */
    private fun getEMUIVersion(): String {
        try {
            val emuiVersion = Build.DISPLAY ?: ""
            val emuiVersionRegex = "EMUI\\s*(\\d+(\\.\\d+)*)".toRegex()
            val matchResult = emuiVersionRegex.find(emuiVersion)
            return matchResult?.groupValues?.get(1) ?: "未知"
        } catch (e: Exception) {
            return "未知"
        }
    }
    
    /**
     * 检查无障碍服务是否启用
     */
    private fun isAccessibilityServiceEnabled(): Boolean {
        try {
            val context = getApplication<Application>()
            val accessibilityManager = context.getSystemService(Context.ACCESSIBILITY_SERVICE) as android.view.accessibility.AccessibilityManager
            
            // 检查是否有我们的无障碍服务在运行
            // 注意：需要先实现无障碍服务类和配置
            val serviceName = "org.soundsync.ebook/.service.AudioCaptureAccessibilityService"
            
            val enabledServices = accessibilityManager.getEnabledAccessibilityServiceList(
                AccessibilityServiceInfo.FEEDBACK_ALL_MASK
            )
            
            for (service in enabledServices) {
                val serviceId = service.id
                if (serviceId == serviceName) {
                    return true
                }
            }
            
            return false
        } catch (e: Exception) {
            Log.e(TAG, "检查无障碍服务状态失败: ${e.message}", e)
            return false
        }
    }

    /**
     * 尝试使用VirtualDisplay方式实现内录
     */
    private fun tryVirtualDisplayRecording(filePath: String): Boolean {
        try {
            Log.d(TAG, "尝试使用VirtualDisplay方式实现内录")
            
            // 此方法需要MediaProjection权限
            val mediaProjection = MainActivity.getMediaProjection() ?: return false
            
            // 华为P30 Pro上尝试使用特殊配置的VirtualDisplay
            if (checkIsHuaweiP30Pro()) {
                // 初始化 MediaRecorder
                mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    MediaRecorder(getApplication())
                } else {
                    @Suppress("DEPRECATION")
                    MediaRecorder()
                }
                
                // 使用特殊配置
                try {
                    // 先尝试REMOTE_SUBMIX音源
                    if (tryWithAudioSource(MediaRecorder.AudioSource.REMOTE_SUBMIX, filePath)) {
                        // 创建虚拟显示
                        configureVirtualDisplay(mediaProjection, filePath)
                        return true
                    }
                    
                    // 如果REMOTE_SUBMIX失败，尝试其他音源
                    val alternativeAudioSources = listOf(
                        MediaRecorder.AudioSource.VOICE_COMMUNICATION,
                        MediaRecorder.AudioSource.VOICE_RECOGNITION,
                        MediaRecorder.AudioSource.CAMCORDER
                    )
                    
                    for (audioSource in alternativeAudioSources) {
                        if (tryWithAudioSource(audioSource, filePath)) {
                            // 创建虚拟显示
                            configureVirtualDisplay(mediaProjection, filePath)
                            return true
                        }
                    }
                    
                    Log.e(TAG, "所有音源均尝试失败")
                    return false
                } catch (e: Exception) {
                    Log.e(TAG, "VirtualDisplay配置失败: ${e.message}", e)
                    releaseMediaRecorder()
                    return false
                }
            }
            
            // 一般VirtualDisplay方法在华为设备上不可用
            return false
        } catch (e: Exception) {
            Log.e(TAG, "VirtualDisplay方法异常: ${e.message}", e)
            return false
        }
    }
    
    /**
     * 配置虚拟显示
     */
    private fun configureVirtualDisplay(mediaProjection: android.media.projection.MediaProjection, filePath: String): Boolean {
        try {
            val displayMetrics = getApplication<Application>().resources.displayMetrics
            val width = 1
            val height = 1
            val density = displayMetrics.densityDpi
            
            val surface = mediaRecorder?.surface
            
            if (surface != null) {
                val virtualDisplay = mediaProjection.createVirtualDisplay(
                    "AudioCapture",
                    width, height, density,
                    android.hardware.display.DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,
                    surface, null, null
                )
                
                // 已经在tryWithAudioSource中开始录制
                Log.d(TAG, "虚拟显示已配置: $filePath")
                return true
            }
            
            return false
        } catch (e: Exception) {
            Log.e(TAG, "配置虚拟显示时发生异常: ${e.message}", e)
            return false
        }
    }

    /**
     * 关闭无障碍服务引导对话框
     */
    fun dismissAccessibilityGuide() {
        _uiState.update { it.copy(showAccessibilityGuide = false) }
    }
}

/**
 * 阅读器UI状态
 */
data class UnifiedReaderUiState(
    val book: Book? = null,
    val currentPage: Int = 0,
    val totalPages: Int = 0,
    val currentChapter: Int = 0,
    val totalChapters: Int = 0,
    val readingProgress: Float = 0f,
    val currentContent: ReaderContent? = null,
    val chapterTitle: String = "",
    val isLoading: Boolean = false,
    val error: String? = null,
    val isSearching: Boolean = false,
    val searchResults: List<SearchResult> = emptyList(),
    val showControls: Boolean = false,
    val ttsRecordEnabled: Boolean = false,
    val records: List<Record> = emptyList(),
    val currentPlayingRecordId: String? = null,
    val showAccessibilityGuide: Boolean = false
) 