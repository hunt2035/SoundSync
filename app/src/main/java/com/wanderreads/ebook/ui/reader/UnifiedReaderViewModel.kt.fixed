package com.wanderreads.ebook.ui.reader

import android.Manifest
import android.app.Application
import android.content.ComponentName
import android.content.Context
import android.content.ContextWrapper
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.media.AudioAttributes
import android.media.MediaPlayer
import android.media.MediaRecorder
import android.os.Build
import android.os.Bundle
import android.os.IBinder
import android.speech.tts.TextToSpeech
import android.speech.tts.TextToSpeech.OnUtteranceProgressListener
import android.speech.tts.TextToSpeech.OnUtteranceProgressListener
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.edit
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.wanderreads.ebook.MainActivity
import com.wanderreads.ebook.data.local.dataStore
import com.wanderreads.ebook.data.repository.BookRepository
import com.wanderreads.ebook.data.repository.RecordRepository
import com.wanderreads.ebook.data.repository.RecordRepositoryImpl
import com.wanderreads.ebook.domain.model.Book
import com.wanderreads.ebook.domain.model.Record
import com.wanderreads.ebook.service.AudioCaptureService
import com.wanderreads.ebook.ui.settings.SettingsViewModel
import com.wanderreads.ebook.util.PageDirection
import com.wanderreads.ebook.util.reader.BookReaderEngine
import com.wanderreads.ebook.util.reader.SearchResult
import com.wanderreads.ebook.util.reader.model.BookChapter
import com.wanderreads.ebook.util.reader.model.ReaderConfig
import com.wanderreads.ebook.util.reader.model.ReaderContent
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.io.File
import java.io.IOException
import java.util.Locale
import java.util.UUID

/**
 * 统一的阅读器ViewModel
 * 支持所有格式的电子书，依赖于BookReaderEngine接口进行实际处理
 */
class UnifiedReaderViewModel(
    application: Application,
    private val bookRepository: BookRepository,
    private val recordRepository: RecordRepository,
    private val bookId: String
) : AndroidViewModel(application) {

    // 阅读引擎
    private var readerEngine: BookReaderEngine? = null
    
    // 录音文件播放相关
    private var mediaPlayer: MediaPlayer? = null
    private var currentPlayingRecord: Record? = null
    
    // UI状态
    private val _uiState = MutableStateFlow(UnifiedReaderUiState())
    val uiState: StateFlow<UnifiedReaderUiState> = _uiState.asStateFlow()
    
    // TTS引擎
    private var tts: TextToSpeech? = null
    private var isTtsActive = false
    
    // 录音相关
    private var mediaRecorder: MediaRecorder? = null
    private var isRecording = false
    private var recordStartTime = 0L
    private var recordFile: File? = null
    private var ttsRecordEnabled = false
    
    // 音频捕获服务
    private var audioCaptureService: AudioCaptureService? = null
    private var serviceBound = false
    
    // 服务连接
    private val serviceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            val binder = service as? AudioCaptureService.LocalBinder
            audioCaptureService = binder?.getService()
            serviceBound = true
            
            // 如果服务连接时已在录音状态，开始实际录音
            if (isRecording && recordFile != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                startInternalRecording()
            }
        }
        
        override fun onServiceDisconnected(name: ComponentName?) {
            audioCaptureService = null
            serviceBound = false
        }
    }
    
    // 常量
    companion object {
        private const val TAG = "UnifiedReaderViewModel"
        private const val RECORDING_PREFIX = "voc_"
    }
    
    init {
        loadBook()
        loadTtsRecordSettings()
        loadBookRecords()
    }
    
    /**
     * 加载TTS录音设置
     */
    private fun loadTtsRecordSettings() {
        viewModelScope.launch {
            try {
                getApplication<Application>().dataStore.data
                    .map { preferences -> 
                        preferences[SettingsViewModel.TTS_RECORD_KEY] ?: false 
                    }
                    .collect { enabled ->
                        ttsRecordEnabled = enabled
                        _uiState.update { it.copy(ttsRecordEnabled = enabled) }
                        Log.d(TAG, "TTS录音设置已加载 ${if (enabled) "启用" else "禁用"}")
                    }
            } catch (e: Exception) {
                Log.e(TAG, "加载TTS录音设置失败: ${e.message}")
            }
        }
    }
    
    /**
     * 设置TTS录音功能开关
     */
    fun setTtsRecordEnabled(enabled: Boolean) {
        viewModelScope.launch {
            try {
                getApplication<Application>().dataStore.edit { preferences ->
                    preferences[SettingsViewModel.TTS_RECORD_KEY] = enabled
                }
                ttsRecordEnabled = enabled
                _uiState.update { it.copy(ttsRecordEnabled = enabled) }
                Log.d(TAG, "TTS录音设置已更新 ${if (enabled) "启用" else "禁用"}")
            } catch (e: Exception) {
                Log.e(TAG, "更新TTS录音设置失败: ${e.message}")
            }
        }
    }
    
    /**
     * 加载书籍
     */
    private fun loadBook() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            try {
                // 从仓库获取书籍信息
                val book = bookRepository.getBookById(bookId)
                
                if (book != null) {
                    // 创建适合此书籍格式的阅读引擎
                    readerEngine = BookReaderEngine.create(getApplication(), book.type)
                    
                    // 初始化引擎
                    readerEngine?.initialize(book, book.lastReadPage)
                    
                    // 加载内容
                    readerEngine?.loadContent()
                    
                    // 初始化UI状态
                    readerEngine?.let { engine ->
                        _uiState.update { state ->
                            state.copy(
                                currentContent = engine.getCurrentPageContent(),
                                chapterTitle = engine.getCurrentChapterTitle()
                            )
                        }
                    }
                    
                    // 订阅引擎状态更新
                    observeEngineState()
                    
                    // 更新书籍的最后打开时间
                    bookRepository.updateLastOpenedDate(book.id, System.currentTimeMillis())
                } else {
                    _uiState.update { it.copy(error = "找不到图片") }
                }
            } catch (e: Exception) {
                _uiState.update { it.copy(error = "加载图书失败: ${e.message}") }
            } finally {
                _uiState.update { it.copy(isLoading = false) }
            }
        }
    }
    
    /**
     * 观察引擎状态
     */
    private fun observeEngineState() {
        readerEngine?.let { engine ->
            viewModelScope.launch {
                engine.state.collect { state ->
                    _uiState.update { uiState ->
                        uiState.copy(
                            book = state.book,
                            currentPage = state.currentPage,
                            totalPages = state.totalPages,
                            currentChapter = state.currentChapter,
                            totalChapters = state.totalChapters,
                            readingProgress = state.readingProgress,
                            currentContent = engine.getCurrentPageContent(),
                            chapterTitle = engine.getCurrentChapterTitle()
                        )
                    }
                }
            }
        }
    }
    
    /**
     * 初始化文本朗读
     */
    fun initTts(onInitListener: (status: Int) -> Unit) {
        if (tts == null) {
            tts = TextToSpeech(getApplication()) { status ->
                if (status == TextToSpeech.SUCCESS) {
                    tts?.language = Locale.CHINESE
                    
                    // 设置TTS进度监听器
                    tts?.setOnUtteranceProgressListener(object : OnUtteranceProgressListener() {
                        override fun onStart(utteranceId: String) {
                            Log.d(TAG, "开始朗读: $utteranceId")
                            
                            // 如果TTS录音功能已启用，开始录音
                            if (ttsRecordEnabled && !isRecording) {
                                startRecording()
                            }
                        }
                        
                        override fun onDone(utteranceId: String) {
                            Log.d(TAG, "朗读完成: $utteranceId")
                            
                            // TTS朗读完成后，如果正在录音，停止录音并保存
                            if (isRecording) {
                                stopRecordingAndSave()
                            }
                            
                            // 如果还在朗读模式，自动朗读下一页
                            if (isTtsActive) {
                                viewModelScope.launch {
                                    if (readerEngine?.hasNextPage() == true) {
                                        navigatePage(PageDirection.NEXT)
                                    } else {
                                        // 已到最后一页，停止朗读
                                        isTtsActive = false
                                    }
                                }
                            }
                        }
                        
                        override fun onError(utteranceId: String) {
                            Log.e(TAG, "朗读错误: $utteranceId")
                            
                            // 如果发生错误，停止录音
                            if (isRecording) {
                                stopRecordingAndSave()
                            }
                            
                            isTtsActive = false
                        }
                    })
                    
                    readerEngine?.initTts(tts!!)
                }
                onInitListener(status)
            }
        } else {
            onInitListener(TextToSpeech.SUCCESS)
        }
    }
    
    /**
     * 开始或停止朗读
     */
    fun toggleTts(): Boolean {
        isTtsActive = !isTtsActive
        
        if (isTtsActive) {
            speakCurrentPage()
        } else {
            tts?.stop()
            
            // 停止TTS时，如果正在录音，停止录音并保存
            if (isRecording) {
                stopRecordingAndSave()
            }
        }
        
        return isTtsActive
    }
    
    /**
     * 朗读当前页面
     */
    private fun speakCurrentPage() {
        val textToSpeak = readerEngine?.getCurrentPageText() ?: return
        
        if (textToSpeak.isNotEmpty() && isTtsActive) {
            val params = Bundle()
            val utteranceId = "TTS_${UUID.randomUUID()}"
            tts?.speak(
                textToSpeak,
                TextToSpeech.QUEUE_FLUSH,
                params,
                utteranceId
            )
            
            // 如果启用了TTS录音，并且当前没有在录音，则开始录音
            if (ttsRecordEnabled && !isRecording) {
                startRecording()
            }
        }
    }
    
    /**
     * 开始录音
     */
    private fun startRecording() {
        try {
            // 检查Android版本
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
                Log.d(TAG, "Android版本低于10，不支持内录功能")
                _uiState.update { it.copy(error = "内录功能需要Android 10或更高版本") }
                return
            }
            
            viewModelScope.launch {
                // 获取MainActivity实例和Context
                val context = getApplication<Application>().applicationContext
                val mainActivity = context.findMainActivity()
                
                // 创建录音目录
                val recordDir = try {
                    (recordRepository as? RecordRepositoryImpl)?.createRecordDirectory()
                } catch (e: Exception) {
                    null
                } ?: File(context.filesDir, "book_records").apply { 
                    if (!exists()) mkdirs() 
                }
                
                // 创建录音文件（使用时间戳作为唯一标识）
                val timestamp = System.currentTimeMillis()
                recordFile = File(recordDir, "${RECORDING_PREFIX}${timestamp}.mp3")
                
                // 标记开始录音
                isRecording = true
                recordStartTime = System.currentTimeMillis()
                
                // 判断服务和媒体投影是否准备就绪
                if (serviceBound && audioCaptureService != null && MainActivity.getMediaProjection() != null) {
                    // 服务和媒体投影都已经就绪，直接开始录音
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        Log.d(TAG, "服务和媒体投影已就绪，直接开始录音")
                        startInternalRecording()
                    }
                } else {
                    // 需要先连接服务和请求媒体投影权限
                    // 连接音频捕获服务
                    bindAudioCaptureService()
                    
                    // 请求媒体投影权限（用于内录）
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                        if (mainActivity != null) {
                            mainActivity.requestMediaProjectionPermission()
                            Log.d(TAG, "录音请求已发送")
                        } else {
                            // 无法获取MainActivity，使用降级策略
                            Log.e(TAG, "无法获取MainActivity实例，使用降级录音方式")
                            
                            if (hasRecordPermission()) {
                                // 降级为标准麦克风录音
                                fallbackToStandardRecording()
                            } else {
                                _uiState.update { it.copy(error = "无法获取主Activity且缺少录音权限") }
                                isRecording = false
                            }
                        }
                    } else {
                        _uiState.update { it.copy(error = "您的设备不支持内录功能") }
                        isRecording = false
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "开始录音失败 ${e.message}", e)
            releaseMediaRecorder()
            _uiState.update { it.copy(error = "录音功能不可用 ${e.message}") }
        }
    }
    
    /**
     * 降级使用标准MediaRecorder录音
     */
    private fun fallbackToStandardRecording() {
        try {
            Log.d(TAG, "使用标准麦克风录音作为降级方式")
            
            // 初始化MediaRecorder
            mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                MediaRecorder(getApplication())
            } else {
                @Suppress("DEPRECATION")
                MediaRecorder()
            }
            
            recordFile?.let { file ->
                mediaRecorder?.apply {
                    try {
                        // 设置音频源和输出格式
                        setAudioSource(MediaRecorder.AudioSource.MIC)
                        setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)
                        setOutputFile(file.absolutePath)
                        setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
                        setAudioSamplingRate(44100)
                        setAudioEncodingBitRate(96000)
                        
                        // 准备并开始录音
                        prepare()
                        start()
                        Log.d(TAG, "降级录音已开始 ${file.absolutePath}")
                    } catch (e: Exception) {
                        Log.e(TAG, "降级录音失败: ${e.message}", e)
                        releaseMediaRecorder()
                        _uiState.update { it.copy(error = "降级录音失败: ${e.message}") }
                        isRecording = false
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "初始化降级录音失败 ${e.message}", e)
            releaseMediaRecorder()
            _uiState.update { it.copy(error = "初始化降级录音失败 ${e.message}") }
            isRecording = false
        }
    }
    
    /**
     * 尝试查找MainActivity实例
     */
    private fun Context.findMainActivity(): MainActivity? {
        Log.d(TAG, "尝试查找MainActivity实例")
        
        try {
            // 1. 首先尝试使用全局单例获取MainActivity
            val mainActivityFromSingleton = MainActivity.getInstance()
            if (mainActivityFromSingleton != null) {
                Log.d(TAG, "从全局单例成功获取MainActivity实例")
                return mainActivityFromSingleton
            }
            
            // 2. 尝试通过上下文链查找
            var currentContext: Context? = this
            while (currentContext != null) {
                // 如果当前上下文就是MainActivity
                if (currentContext is MainActivity) {
                    Log.d(TAG, "在上下文链中找到MainActivity实例")
                    return currentContext
                }
                
                // 向上查找
                if (currentContext is ContextWrapper) {
                    currentContext = currentContext.baseContext
                } else {
                    // 如果不是ContextWrapper，无法再向上查找
                    break
                }
            }
    
            // 3. 所有尝试都失败，记录日志
            Log.e(TAG, "无法找到MainActivity实例，将使用降级录音方式")
            return null
        } catch (e: Exception) {
            Log.e(TAG, "查找MainActivity过程中发生异常 ${e.message}", e)
            return null
        }
    }
    
    /**
     * 检查是否有录音权限
     */
    private fun hasRecordPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            getApplication(),
            Manifest.permission.RECORD_AUDIO
        ) == PackageManager.PERMISSION_GRANTED
    }
    
    /**
     * 停止录音并保存到数据库
     */
    private fun stopRecordingAndSave() {
        if (!isRecording || recordFile == null) return
        
        try {
            // 如果使用了内录服务
            if (audioCaptureService != null && serviceBound) {
                // 停止内录服务的录音
                val recordedFilePath = audioCaptureService?.stopRecording()
                
                if (recordedFilePath == null) {
                    Log.e(TAG, "内录保存失败：未获取到录音文件路径")
                    _uiState.update { it.copy(error = "内录保存失败") }
                }
            } else if (mediaRecorder != null) {
                // 如果使用的是降级为标准MediaRecorder
                try {
                    mediaRecorder?.apply {
                        stop()
                        reset()
                        release()
                    }
                    mediaRecorder = null
                } catch (e: Exception) {
                    Log.e(TAG, "停止降级录音失败: ${e.message}", e)
                    recordFile?.delete()
                    _uiState.update { it.copy(error = "停止录音失败: ${e.message}") }
                    isRecording = false
                    return
                }
            } else {
                Log.e(TAG, "录音未正确初始化")
                recordFile?.delete()
                isRecording = false
                return
            }
            
            isRecording = false
            
            // 计算录音时长（秒）
            val recordDuration = ((System.currentTimeMillis() - recordStartTime) / 1000).toInt()
            
            if (recordDuration <= 1) {
                // 录音时间太短，删除文件
                Log.d(TAG, "录音时间太短，删除录音文件")
                recordFile?.delete()
                return
            }
            
            // 保存录音信息到数据库
            viewModelScope.launch {
                val record = Record(
                    bookId = bookId,
                    voiceFilePath = recordFile?.absolutePath ?: "",
                    voiceLength = recordDuration,
                    addedDate = System.currentTimeMillis()
                )
                
                try {
                    val recordId = recordRepository.addRecord(record)
                    Log.d(TAG, "录音已保存到数据库 $recordId")
                } catch (e: Exception) {
                    Log.e(TAG, "保存录音数据失败: ${e.message}")
                }
            }
            
            Log.d(TAG, "录音已停止并保存: ${recordFile?.absolutePath}, 时长: ${recordDuration}秒")
        } catch (e: Exception) {
            Log.e(TAG, "停止录音失败: ${e.message}")
        } finally {
            releaseMediaRecorder()
        }
    }
    
    /**
     * 释放MediaRecorder资源
     */
    private fun releaseMediaRecorder() {
        try {
            mediaRecorder?.reset()
            mediaRecorder?.release()
            mediaRecorder = null
            isRecording = false
            
            // 断开录音服务
            unbindAudioCaptureService()
        } catch (e: Exception) {
            Log.e(TAG, "释放MediaRecorder失败: ${e.message}")
        }
    }
    
    /**
     * 翻页
     */
    fun navigatePage(direction: PageDirection) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止当前页的朗读
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.navigatePage(direction)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 跳转到指定页面
     */
    fun goToPage(page: Int) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.goToPage(page)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 跳转到指定章节
     */
    fun goToChapter(chapterIndex: Int) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.goToChapter(chapterIndex)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 获取当前页面内容
     */
    fun getContentForCurrentPage(): String {
        return readerEngine?.getCurrentPageText() ?: ""
    }
    
    /**
     * 获取章节列表
     */
    fun getChapters(): List<BookChapter> {
        return readerEngine?.getChapters() ?: emptyList()
    }
    
    /**
     * 更新阅读器配置
     */
    fun updateConfig(config: ReaderConfig) {
        viewModelScope.launch {
            readerEngine?.updateConfig(config)
        }
    }
    
    /**
     * 保存阅读进度
     */
    private suspend fun saveReadingProgress() {
        val book = uiState.value.book ?: return
        val currentPage = uiState.value.currentPage
        
        try {
            bookRepository.updateReadingProgress(
                bookId = book.id,
                lastReadPage = currentPage,
                lastReadPosition = uiState.value.readingProgress
            )
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "保存进度失败: ${e.message}") }
        }
    }
    
    /**
     * 搜索文本
     */
    fun searchText(query: String) {
        viewModelScope.launch {
            try {
                _uiState.update { it.copy(isSearching = true) }
                
                val results = readerEngine?.searchText(query) ?: emptyList()
                
                _uiState.update { state ->
                    state.copy(
                        searchResults = results,
                        isSearching = false
                    )
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        error = "搜索失败: ${e.message}",
                        isSearching = false
                    ) 
                }
            }
        }
    }
    
    /**
     * 获取书籍封面
     */
    fun getBookCover(): Bitmap? {
        return uiState.value.book?.coverPath?.let {
            try {
                android.graphics.BitmapFactory.decodeFile(it)
            } catch (e: Exception) {
                null
            }
        }
    }
    
    /**
     * 加载当前书籍的录音文件
     */
    private fun loadBookRecords() {
        viewModelScope.launch {
            try {
                recordRepository.getRecordsByBookId(bookId).collect { records ->
                    _uiState.update { it.copy(records = records) }
                    Log.d(TAG, "已加载${records.size} 个录音文件")
                }
            } catch (e: Exception) {
                Log.e(TAG, "加载录音文件失败: ${e.message}")
            }
        }
    }
    
    /**
     * 播放录音文件
     */
    fun playRecord(record: Record) {
        try {
            // 如果有正在播放的录音，先停止
            stopPlayingRecord()
            
            val recordFile = File(record.voiceFilePath)
            if (!recordFile.exists()) {
                Log.e(TAG, "录音文件不存在 ${record.voiceFilePath}")
                return
            }
            
            mediaPlayer = MediaPlayer().apply {
                setAudioAttributes(
                    AudioAttributes.Builder()
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .build()
                )
                setDataSource(record.voiceFilePath)
                setOnPreparedListener { mp ->
                    mp.start()
                    currentPlayingRecord = record
                    _uiState.update { it.copy(currentPlayingRecordId = record.recId) }
                }
                setOnCompletionListener {
                    stopPlayingRecord()
                }
                prepareAsync()
            }
        } catch (e: Exception) {
            Log.e(TAG, "播放录音文件失败: ${e.message}")
            stopPlayingRecord()
        }
    }
    
    /**
     * 暂停播放录音
     */
    fun pauseRecord(record: Record) {
        try {
            if (currentPlayingRecord?.recId == record.recId && mediaPlayer?.isPlaying == true) {
                mediaPlayer?.pause()
                _uiState.update { it.copy(currentPlayingRecordId = null) }
                currentPlayingRecord = null
            }
        } catch (e: Exception) {
            Log.e(TAG, "暂停录音文件失败: ${e.message}")
        }
    }
    
    /**
     * 停止播放录音文件
     */
    private fun stopPlayingRecord() {
        try {
            mediaPlayer?.apply {
                if (isPlaying) {
                    stop()
                }
                reset()
                release()
            }
            mediaPlayer = null
            currentPlayingRecord = null
            _uiState.update { it.copy(currentPlayingRecordId = null) }
        } catch (e: Exception) {
            Log.e(TAG, "停止播放录音文件失败: ${e.message}")
        }
    }
    
    /**
     * 清理资源
     */
    override fun onCleared() {
        super.onCleared()
        
        viewModelScope.launch {
            saveReadingProgress()
            
            // 停止TTS
            tts?.stop()
            tts?.shutdown()
            tts = null
            
            // 停止录音
            if (isRecording) {
                stopRecordingAndSave()
            }
            
            // 释放播放器资源
            stopPlayingRecord()
            
            readerEngine?.close()
            readerEngine = null
        }
        
        // 清理服务连接
        try {
            if (serviceBound) {
                getApplication<Application>().applicationContext.unbindService(serviceConnection)
                serviceBound = false
                audioCaptureService = null
            }
        } catch (e: Exception) {
            Log.e(TAG, "解绑服务失败: ${e.message}")
        }
    }

    private fun formatProgressText(): String {
        val currentPage = uiState.value.currentPage + 1
        val totalPages = uiState.value.totalPages
        return "${currentPage}/${totalPages}"
    }

    /**
     * 连接音频捕获服务
     */
    private fun bindAudioCaptureService() {
        if (!serviceBound) {
            val context = getApplication<Application>().applicationContext
            val intent = Intent(context, AudioCaptureService::class.java)
            context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)
        }
    }
    
    /**
     * 断开音频捕获服务
     */
    private fun unbindAudioCaptureService() {
        if (serviceBound) {
            getApplication<Application>().applicationContext.unbindService(serviceConnection)
            serviceBound = false
            audioCaptureService = null
        }
    }
    
    /**
     * 开始内部录音过程（由服务执行）
     */
    @RequiresApi(Build.VERSION_CODES.Q)
    private fun startInternalRecording() {
        recordFile?.let { file ->
            if (audioCaptureService?.startRecording(file.absolutePath) == true) {
                Log.d(TAG, "内录功能已成功启动 ${file.absolutePath}")
            } else {
                _uiState.update { it.copy(error = "无法启动内录功能") }
                isRecording = false
            }
        }
    }
}

/**
 * 阅读器UI状态
 */
data class UnifiedReaderUiState(
    val book: Book? = null,
    val currentPage: Int = 0,
    val totalPages: Int = 0,
    val currentChapter: Int = 0,
    val totalChapters: Int = 0,
    val readingProgress: Float = 0f,
    val currentContent: ReaderContent? = null,
    val chapterTitle: String = "",
    val isLoading: Boolean = false,
    val error: String? = null,
    val isSearching: Boolean = false,
    val searchResults: List<SearchResult> = emptyList(),
    val showControls: Boolean = false,
    val ttsRecordEnabled: Boolean = false,
    val records: List<Record> = emptyList(),
    val currentPlayingRecordId: Long? = null
) 
