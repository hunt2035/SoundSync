package com.wanderreads.ebook.ui.reader

import android.Manifest
import android.app.Application
import android.accessibilityservice.AccessibilityServiceInfo
import android.content.ComponentName
import android.content.Context
import android.content.ContextWrapper
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.media.AudioAttributes
import android.media.MediaPlayer
import android.media.MediaRecorder
import android.os.Build
import android.os.Bundle
import android.os.IBinder
import android.os.Handler
import android.os.Looper
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.edit
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.wanderreads.ebook.MainActivity
import com.wanderreads.ebook.R
import com.wanderreads.ebook.data.local.dataStore
import com.wanderreads.ebook.data.repository.BookRepository
import com.wanderreads.ebook.data.repository.RecordRepository
import com.wanderreads.ebook.data.repository.RecordRepositoryImpl
import com.wanderreads.ebook.domain.model.Book
import com.wanderreads.ebook.domain.model.Record
import com.wanderreads.ebook.service.AudioCaptureService
import com.wanderreads.ebook.ui.settings.SettingsViewModel
import com.wanderreads.ebook.util.PageDirection
import com.wanderreads.ebook.util.reader.BookReaderEngine
import com.wanderreads.ebook.util.reader.SearchResult
import com.wanderreads.ebook.util.reader.model.BookChapter
import com.wanderreads.ebook.util.reader.model.ReaderConfig
import com.wanderreads.ebook.util.reader.model.ReaderContent
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.io.File
import java.io.IOException
import java.util.Locale
import java.util.UUID
import kotlinx.coroutines.delay

/**
 * 统一的阅读器ViewModel
 * 支持所有格式的电子书，依赖于BookReaderEngine接口进行实际处理
 */
class UnifiedReaderViewModel(
    application: Application,
    private val bookRepository: BookRepository,
    private val recordRepository: RecordRepository,
    private val bookId: String
) : AndroidViewModel(application) {

    // 阅读引擎
    private var readerEngine: BookReaderEngine? = null
    
    // 录音文件播放相关
    private var mediaPlayer: MediaPlayer? = null
    private var currentPlayingRecord: Record? = null
    
    // UI状态
    private val _uiState = MutableStateFlow(UnifiedReaderUiState())
    val uiState: StateFlow<UnifiedReaderUiState> = _uiState.asStateFlow()
    
    // TTS引擎
    private var tts: TextToSpeech? = null
    private var isTtsActive = false
    
    // 录音相关
    private var mediaRecorder: MediaRecorder? = null
    private var isRecording = false
    private var recordStartTime = 0L
    private var recordFile: File? = null
    private var ttsRecordEnabled = false
    
    // 常量
    companion object {
        private const val TAG = "UnifiedReaderViewModel"
        private const val RECORDING_PREFIX = "voc_"
    }
    
    init {
        loadBook()
        loadTtsRecordSettings()
    }
    
    /**
     * 加载TTS录音设置
     */
    private fun loadTtsRecordSettings() {
        viewModelScope.launch {
            try {
                getApplication<Application>().dataStore.data
                    .map { preferences -> 
                        preferences[SettingsViewModel.TTS_RECORD_KEY] ?: false 
                    }
                    .collect { enabled ->
                        ttsRecordEnabled = enabled
                        _uiState.update { it.copy(ttsRecordEnabled = enabled) }
                        Log.d(TAG, "TTS录音设置已加载: 已${if (enabled) "启用" else "禁用"}")
                    }
            } catch (e: Exception) {
                Log.e(TAG, "加载TTS录音设置失败: ${e.message}")
            }
        }
    }
    
    /**
     * 设置TTS录音功能开关
     */
    fun setTtsRecordEnabled(enabled: Boolean) {
        viewModelScope.launch {
            try {
                getApplication<Application>().dataStore.edit { preferences ->
                    preferences[SettingsViewModel.TTS_RECORD_KEY] = enabled
                }
                ttsRecordEnabled = enabled
                _uiState.update { it.copy(ttsRecordEnabled = enabled) }
                Log.d(TAG, "TTS录音设置已更新: 已${if (enabled) "启用" else "禁用"}")
            } catch (e: Exception) {
                Log.e(TAG, "更新TTS录音设置失败: ${e.message}")
            }
        }
    }
    
    /**
     * 加载书籍
     */
    private fun loadBook() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            try {
                // 从仓库获取书籍信息
                val book = bookRepository.getBookById(bookId)
                
                if (book != null) {
                    // 创建适合此书籍格式的阅读引擎
                    readerEngine = BookReaderEngine.create(getApplication(), book.type)
                    
                    // 初始化引擎
                    readerEngine?.initialize(book, book.lastReadPage)
                    
                    // 加载内容
                    readerEngine?.loadContent()
                    
                    // 初始化UI状态
                    readerEngine?.let { engine ->
                        _uiState.update { state ->
                            state.copy(
                                currentContent = engine.getCurrentPageContent(),
                                chapterTitle = engine.getCurrentChapterTitle()
                            )
                        }
                    }
                    
                    // 订阅引擎状态更新
                    observeEngineState()
                    
                    // 更新书籍的最后打开时间
                    bookRepository.updateLastOpenedDate(book.id, System.currentTimeMillis())
                } else {
                    _uiState.update { it.copy(error = "找不到图书") }
                }
            } catch (e: Exception) {
                _uiState.update { it.copy(error = "加载图书失败: ${e.message}") }
            } finally {
                _uiState.update { it.copy(isLoading = false) }
            }
        }
    }
    
    /**
     * 观察引擎状态
     */
    private fun observeEngineState() {
        readerEngine?.let { engine ->
            viewModelScope.launch {
                engine.state.collect { state ->
                    _uiState.update { uiState ->
                        uiState.copy(
                            book = state.book,
                            currentPage = state.currentPage,
                            totalPages = state.totalPages,
                            currentChapter = state.currentChapter,
                            totalChapters = state.totalChapters,
                            readingProgress = state.readingProgress,
                            currentContent = engine.getCurrentPageContent(),
                            chapterTitle = engine.getCurrentChapterTitle()
                        )
                    }
                }
            }
        }
    }
    
    /**
     * 初始化文本朗读
     */
    fun initTts(onInitListener: (status: Int) -> Unit) {
        if (tts == null) {
            tts = TextToSpeech(getApplication()) { status ->
                if (status == TextToSpeech.SUCCESS) {
                    tts?.language = Locale.CHINESE
                    
                    // 设置TTS进度监听器
                    tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                        override fun onStart(utteranceId: String?) {
                            Log.d(TAG, "开始朗读: $utteranceId")
                            
                            // 如果TTS录音功能已启用，开始录音
                            if (ttsRecordEnabled && !isRecording) {
                                startRecording()
                            }
                        }
                        
                        override fun onDone(utteranceId: String?) {
                            Log.d(TAG, "朗读完成: $utteranceId")
                            
                            // TTS朗读完成后，如果正在录音，停止录音并保存
                            if (isRecording) {
                                stopRecordingAndSave()
                            }
                            
                            // 如果还在朗读模式，自动朗读下一页
                            if (isTtsActive) {
                                viewModelScope.launch {
                                    if (readerEngine?.hasNextPage() == true) {
                                        navigatePage(PageDirection.NEXT)
                                    } else {
                                        // 已到最后一页，停止朗读
                                        isTtsActive = false
                                    }
                                }
                            }
                        }
                        
                        override fun onError(utteranceId: String?) {
                            Log.e(TAG, "朗读错误: $utteranceId")
                            
                            // 如果发生错误，停止录音
                            if (isRecording) {
                                stopRecordingAndSave()
                            }
                            
                            isTtsActive = false
                        }
                    })
                    
                    readerEngine?.initTts(tts!!)
                }
                onInitListener(status)
            }
        } else {
            onInitListener(TextToSpeech.SUCCESS)
        }
    }
    
    /**
     * 开始或停止朗读
     */
    fun toggleTts(): Boolean {
        isTtsActive = !isTtsActive
        
        if (isTtsActive) {
            speakCurrentPage()
        } else {
            tts?.stop()
            
            // 停止TTS时，如果正在录音，停止录音并保存
            if (isRecording) {
                stopRecordingAndSave()
            }
        }
        
        return isTtsActive
    }
    
    /**
     * 朗读当前页面
     */
    private fun speakCurrentPage() {
        val textToSpeak = readerEngine?.getCurrentPageText() ?: return
        
        if (textToSpeak.isNotEmpty() && isTtsActive) {
            val params = Bundle()
            val utteranceId = "TTS_${UUID.randomUUID()}"
            tts?.speak(
                textToSpeak,
                TextToSpeech.QUEUE_FLUSH,
                params,
                utteranceId
            )
            
            // 如果启用了TTS录音，并且当前没有在录音，则开始录音
            if (ttsRecordEnabled && !isRecording) {
                startRecording()
            }
        }
    }
    
    /**
     * 开始录音
     */
    private fun startRecording() {
        try {
            viewModelScope.launch {
                // 创建录音目录
                val recordDir = (recordRepository as? RecordRepositoryImpl)?.createRecordDirectory()
                    ?: File(getApplication<Application>().filesDir, "book_records").apply { 
                        if (!exists()) mkdirs() 
                    }
                
                // 创建录音文件（使用时间戳作为唯一标识）
                val timestamp = System.currentTimeMillis()
                recordFile = File(recordDir, "${RECORDING_PREFIX}${timestamp}.mp3")
                
                // 初始化 MediaRecorder
                mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    MediaRecorder(getApplication())
                } else {
                    @Suppress("DEPRECATION")
                    MediaRecorder()
                }
                
                mediaRecorder?.apply {
                    setAudioSource(MediaRecorder.AudioSource.VOICE_RECOGNITION)
                    setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)
                    setOutputFile(recordFile?.absolutePath)
                    setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
                    setAudioSamplingRate(44100)
                    setAudioEncodingBitRate(96000)
                    
                    try {
                        prepare()
                        start()
                        isRecording = true
                        recordStartTime = System.currentTimeMillis()
                        Log.d(TAG, "录音已开始: ${recordFile?.absolutePath}")
                    } catch (e: IOException) {
                        Log.e(TAG, "录音准备失败: ${e.message}")
                        releaseMediaRecorder()
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "开始录音失败: ${e.message}")
            releaseMediaRecorder()
        }
    }
    
    /**
     * 停止录音并保存到数据库
     */
    private fun stopRecordingAndSave() {
        if (!isRecording || mediaRecorder == null || recordFile == null) return
        
        try {
            mediaRecorder?.apply {
                stop()
                reset()
                release()
            }
            
            mediaRecorder = null
            isRecording = false
            
            // 计算录音时长（秒）
            val recordDuration = ((System.currentTimeMillis() - recordStartTime) / 1000).toInt()
            
            if (recordDuration <= 1) {
                // 录音时间太短，删除文件
                Log.d(TAG, "录音时间太短，删除录音文件")
                recordFile?.delete()
                return
            }
            
            // 保存录音信息到数据库
            viewModelScope.launch {
                val record = Record(
                    bookId = bookId,
                    voiceFilePath = recordFile?.absolutePath ?: "",
                    voiceLength = recordDuration,
                    addedDate = System.currentTimeMillis()
                )
                
                try {
                    val recordId = recordRepository.addRecord(record)
                    Log.d(TAG, "录音已保存到数据库: $recordId")
                } catch (e: Exception) {
                    Log.e(TAG, "保存录音数据失败: ${e.message}")
                }
            }
            
            Log.d(TAG, "录音已停止并保存: ${recordFile?.absolutePath}, 时长: ${recordDuration}秒")
        } catch (e: Exception) {
            Log.e(TAG, "停止录音失败: ${e.message}")
        } finally {
            releaseMediaRecorder()
        }
    }
    
    /**
     * 释放MediaRecorder资源
     */
    private fun releaseMediaRecorder() {
        try {
            mediaRecorder?.reset()
            mediaRecorder?.release()
            mediaRecorder = null
            isRecording = false
        } catch (e: Exception) {
            Log.e(TAG, "释放MediaRecorder失败: ${e.message}")
        }
    }
    
    /**
     * 翻页
     */
    fun navigatePage(direction: PageDirection) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止当前页的朗读
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.navigatePage(direction)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 跳转到指定页面
     */
    fun goToPage(page: Int) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.goToPage(page)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 跳转到指定章节
     */
    fun goToChapter(chapterIndex: Int) {
        viewModelScope.launch {
            if (isTtsActive) {
                // 如果正在朗读，先停止
                tts?.stop()
                
                // 如果正在录音，保存当前录音
                if (isRecording) {
                    stopRecordingAndSave()
                }
            }
            
            readerEngine?.goToChapter(chapterIndex)
            
            // 更新当前页内容和章节标题
            readerEngine?.let { engine ->
                _uiState.update { state ->
                    state.copy(
                        currentContent = engine.getCurrentPageContent(),
                        chapterTitle = engine.getCurrentChapterTitle()
                    )
                }
            }
            
            // 如果正在朗读，自动朗读新的页面
            if (isTtsActive) {
                speakCurrentPage()
            }
        }
    }
    
    /**
     * 获取当前页面内容
     */
    fun getContentForCurrentPage(): String {
        return readerEngine?.getCurrentPageText() ?: ""
    }
    
    /**
     * 获取章节列表
     */
    fun getChapters(): List<BookChapter> {
        return readerEngine?.getChapters() ?: emptyList()
    }
    
    /**
     * 更新阅读器配置
     */
    fun updateConfig(config: ReaderConfig) {
        viewModelScope.launch {
            readerEngine?.updateConfig(config)
        }
    }
    
    /**
     * 保存阅读进度
     */
    private suspend fun saveReadingProgress() {
        val book = uiState.value.book ?: return
        val currentPage = uiState.value.currentPage
        
        try {
            bookRepository.updateReadingProgress(
                bookId = book.id,
                lastReadPage = currentPage,
                lastReadPosition = uiState.value.readingProgress
            )
        } catch (e: Exception) {
            _uiState.update { it.copy(error = "保存进度失败: ${e.message}") }
        }
    }
    
    /**
     * 搜索文本
     */
    fun searchText(query: String) {
        viewModelScope.launch {
            try {
                _uiState.update { it.copy(isSearching = true) }
                
                val results = readerEngine?.searchText(query) ?: emptyList()
                
                _uiState.update { state ->
                    state.copy(
                        searchResults = results,
                        isSearching = false
                    )
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        error = "搜索失败: ${e.message}",
                        isSearching = false
                    ) 
                }
            }
        }
    }
    
    /**
     * 获取书籍封面
     */
    fun getBookCover(): Bitmap? {
        return uiState.value.book?.coverPath?.let {
            try {
                android.graphics.BitmapFactory.decodeFile(it)
            } catch (e: Exception) {
                null
            }
        }
    }
    
    /**
     * 清理资源
     */
    override fun onCleared() {
        super.onCleared()
        
        viewModelScope.launch {
            saveReadingProgress()
            
            // 停止TTS
            tts?.stop()
            tts?.shutdown()
            tts = null
            
            // 停止录音
            if (isRecording) {
                stopRecordingAndSave()
            }
            
            readerEngine?.close()
            readerEngine = null
        }
    }

    private fun formatProgressText(): String {
        val currentPage = uiState.value.currentPage + 1
        val totalPages = uiState.value.totalPages
        return "${currentPage}/${totalPages}"
    }
}

/**
 * 统一阅读器UI状态
 */
data class UnifiedReaderUiState(
    val book: Book? = null,
    val isLoading: Boolean = false,
    val error: String? = null,
    val currentPage: Int = 0,
    val totalPages: Int = 0,
    val currentChapter: Int = 0,
    val totalChapters: Int = 0,
    val chapterTitle: String = "",
    val currentContent: ReaderContent? = null,
    val readingProgress: Float = 0f,
    val config: ReaderConfig = ReaderConfig(),
    val isSearching: Boolean = false,
    val searchResults: List<SearchResult> = emptyList(),
    val showControls: Boolean = false,
    val ttsRecordEnabled: Boolean = false
) 